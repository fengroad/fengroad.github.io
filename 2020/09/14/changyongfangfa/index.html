<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>常用方法集合 | Feng</title><meta name="description" content="STL基础容器基础知识vector 单向开口的连续线性空间。 有两个成员函数：capacity和reserve。前者获取容器在分配新的存储空间前能存储的元素总数；后者告诉容器应该预留多少个元素的存储空间。 capacity和size的区别：size是元素个数的；capacity是已分配的内存能放多少元素。 迭代器：插入元素后，指向插入元素后的迭代器全部失效；但元素个数增加到超过capacity时，"><meta name="author" content="feng"><meta name="copyright" content="feng"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="常用方法集合"><meta name="twitter:description" content="STL基础容器基础知识vector 单向开口的连续线性空间。 有两个成员函数：capacity和reserve。前者获取容器在分配新的存储空间前能存储的元素总数；后者告诉容器应该预留多少个元素的存储空间。 capacity和size的区别：size是元素个数的；capacity是已分配的内存能放多少元素。 迭代器：插入元素后，指向插入元素后的迭代器全部失效；但元素个数增加到超过capacity时，"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="常用方法集合"><meta property="og:url" content="http://yoursite.com/2020/09/14/changyongfangfa/"><meta property="og:site_name" content="Feng"><meta property="og:description" content="STL基础容器基础知识vector 单向开口的连续线性空间。 有两个成员函数：capacity和reserve。前者获取容器在分配新的存储空间前能存储的元素总数；后者告诉容器应该预留多少个元素的存储空间。 capacity和size的区别：size是元素个数的；capacity是已分配的内存能放多少元素。 迭代器：插入元素后，指向插入元素后的迭代器全部失效；但元素个数增加到超过capacity时，"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-09-14T13:46:05.591Z"><meta property="article:modified_time" content="2020-09-14T14:01:37.574Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/09/14/changyongfangfa/"><link rel="next" title="排序算法总结" href="http://yoursite.com/2020/09/11/sort_sum/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://fengroad.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL基础"><span class="toc-number">1.</span> <span class="toc-text">STL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器基础知识"><span class="toc-number">1.1.</span> <span class="toc-text">容器基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.1.1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">1.1.2.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque"><span class="toc-number">1.1.3.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">1.1.4.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.1.5.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联容器"><span class="toc-number">1.1.6.</span> <span class="toc-text">关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#智能指针"><span class="toc-number">1.1.7.</span> <span class="toc-text">智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-unordered-map-常见操作"><span class="toc-number">1.2.</span> <span class="toc-text">1 unordered_map 常见操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查找key是否存在"><span class="toc-number">1.2.1.</span> <span class="toc-text">查找key是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-number">1.2.2.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入数据"><span class="toc-number">1.2.3.</span> <span class="toc-text">插入数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-vector"><span class="toc-number">1.3.</span> <span class="toc-text">2 vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-初始化"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二维数组初始化："><span class="toc-number">1.3.1.0.1.</span> <span class="toc-text">二维数组初始化：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-size"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.size()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-返回数组最大值元素"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.返回数组最大值元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-求交集"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.求交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-遍历"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-string"><span class="toc-number">1.4.</span> <span class="toc-text">3 string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">1.4.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#截取一段字符串"><span class="toc-number">1.4.2.</span> <span class="toc-text">截取一段字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断字符是否为十进制数字字符"><span class="toc-number">1.4.3.</span> <span class="toc-text">判断字符是否为十进制数字字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将数字字符化为int数字"><span class="toc-number">1.4.4.</span> <span class="toc-text">将数字字符化为int数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取输入的一整行string，-要空格"><span class="toc-number">1.4.5.</span> <span class="toc-text">获取输入的一整行string，(要空格)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sprintf-转换成十六进制"><span class="toc-number">1.4.6.</span> <span class="toc-text">sprintf()转换成十六进制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x转换成十六进制"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">%x转换成十六进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较两字符串是否相等"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">比较两字符串是否相等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字母大小写转换"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">字母大小写转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple-元组"><span class="toc-number">1.5.</span> <span class="toc-text">tuple 元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-定义与初始化"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.定义与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-访问"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tie批量赋值"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.tie批量赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-语法基础"><span class="toc-number">2.</span> <span class="toc-text">C++语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-预处理器"><span class="toc-number">2.0.1.</span> <span class="toc-text">C 预处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量、局部变量"><span class="toc-number">2.0.2.</span> <span class="toc-text">全局变量、局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-作用"><span class="toc-number">2.0.3.</span> <span class="toc-text">static 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">2.0.4.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理和释放"><span class="toc-number">2.0.5.</span> <span class="toc-text">内存管理和释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数重载"><span class="toc-number">2.1.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数模板与泛型"><span class="toc-number">2.1.2.</span> <span class="toc-text">函数模板与泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-函数模板"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">1.函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-类模板"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2.类模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针和引用"><span class="toc-number">2.1.3.</span> <span class="toc-text">指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#指针"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数指针"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用"><span class="toc-number">2.1.4.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-引用"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">const 引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类"><span class="toc-number">2.1.5.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#访问标号"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">访问标号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类成员"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成员函数的重载、覆盖和隐藏"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">成员函数的重载、覆盖和隐藏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入cin："><span class="toc-number">2.2.</span> <span class="toc-text">输入cin：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出cout"><span class="toc-number">2.3.</span> <span class="toc-text">输出cout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#“-gt-gt-”应用于求中值"><span class="toc-number">2.4.</span> <span class="toc-text">“&gt;&gt;”应用于求中值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i-和-i的区别"><span class="toc-number">2.5.</span> <span class="toc-text">i++和++i的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cout设置输出数据不显示科学计数法"><span class="toc-number">2.5.1.</span> <span class="toc-text">cout设置输出数据不显示科学计数法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">3.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程管理"><span class="toc-number">3.1.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程"><span class="toc-number">3.1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">3.1.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-进程与线程的区别："><span class="toc-number">3.1.2.1.</span> <span class="toc-text">3. 进程与线程的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程通信与进程同步"><span class="toc-number">3.1.3.</span> <span class="toc-text">进程通信与进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度算法"><span class="toc-number">3.1.4.</span> <span class="toc-text">调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">3.1.5.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">3.2.</span> <span class="toc-text">内存管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据结构基础"><span class="toc-number">4.</span> <span class="toc-text">数据结构基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-数组指针、指针数组、数组名的指针操作"><span class="toc-number">4.1.</span> <span class="toc-text">1.数组指针、指针数组、数组名的指针操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针运算"><span class="toc-number">4.1.1.</span> <span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针数组、数组指针"><span class="toc-number">4.1.2.</span> <span class="toc-text">指针数组、数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对于高维数组"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">对于高维数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-字符串"><span class="toc-number">4.2.</span> <span class="toc-text">2.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串处理函数"><span class="toc-number">4.2.1.</span> <span class="toc-text">字符串处理函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-结构体struct"><span class="toc-number">4.3.</span> <span class="toc-text">3.结构体struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct"><span class="toc-number">4.3.1.</span> <span class="toc-text">struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union-共用体"><span class="toc-number">4.3.2.</span> <span class="toc-text">union 共用体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字节序"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">字节序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举（enum）"><span class="toc-number">4.3.3.</span> <span class="toc-text">枚举（enum）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof"><span class="toc-number">4.3.4.</span> <span class="toc-text">sizeof</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-number">4.4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历方式"><span class="toc-number">4.4.1.</span> <span class="toc-text">遍历方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他方法记录"><span class="toc-number">5.</span> <span class="toc-text">其他方法记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进制转换"><span class="toc-number">5.1.</span> <span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#two-pointers"><span class="toc-number">5.2.</span> <span class="toc-text">two pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是two-pointers"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是two pointers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译原理"><span class="toc-number">5.3.</span> <span class="toc-text">编译原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#【makefile】"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">【makefile】</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Feng</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">常用方法集合</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-14 21:46:05"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-09-14</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-14 22:01:37"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-14</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="STL基础"><a href="#STL基础" class="headerlink" title="STL基础"></a>STL基础</h1><h2 id="容器基础知识"><a href="#容器基础知识" class="headerlink" title="容器基础知识"></a>容器基础知识</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul>
<li>单向开口的<strong>连续线性</strong>空间。</li>
<li>有两个成员函数：<strong>capacity和reserve</strong>。前者获取容器在分配新的存储空间前能存储的元素总数；后者告诉容器应该预留多少个元素的存储空间。</li>
<li>capacity和size的<strong>区别</strong>：size是元素个数的；capacity是已分配的内存能放多少元素。</li>
<li><strong>迭代器</strong>：插入元素后，指向插入元素后的迭代器全部失效；但元素个数增加到超过capacity时，内存会重新分配，所有的迭代器失效。删除元素后，被删除元素后的迭代器全部失效。</li>
<li>可以随机访问元素，且速度快。因为vector 的<strong>每次访问都是距离其起点的固定偏移</strong>。</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list内部数据结构时一个<strong>双向环状链表</strong>，故不能随机访问，但可双向遍历、动态增加减少元素。</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><ul>
<li>双向开口的<strong>连续线性空间</strong>。</li>
<li>可以在头尾都做插入、删除操作</li>
<li>没有capacity的概念。因为可以随时可以增加一段新的空间并链接起来。</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>一般使用vector 作为底层存储方式，</p>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>前面都时顺序容器，关联容器和顺序容器的本质差别在于：关联容器通过键(Key)存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。虽然关联容器的大部分行为与顺序容器相同，但其独特之处在于支持键的使用。</p>
<p>注意: map、set、 multimap、 multiset 都是用<strong>红黑树</strong>实现的。</p>
<ol>
<li>map<br>所有元素都会<strong>根据元素的键值被自动排序</strong>。map所有元素都是pair。同时拥有<strong>实值(value)和键值(key)</strong>。map 不允许两个元素有相同的键值。</li>
<li>multimap<br>特性与用法与map完全相同，差别是<strong>允许键值重复</strong>。</li>
<li>set  </li>
</ol>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><strong>1. auto_ptr</strong>  </p>
<ul>
<li>auto_ptr在构造时获取某个对象的所有权，在析构时释放该对象。<br>可以利用智能指针的自动析构，来加强代码安全性：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p &#x3D; new int(0);</span><br><span class="line">auto_ptr&lt;int&gt; ap(p); 或auto ap(p)</span><br></pre></td></tr></table></figure></li>
<li>auto_ptr是<strong>为了解决</strong>“被异常抛出时发送资源泄露”的问题。即，局部对象自动构造、自动析构。  </li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>两个auto_ptr<strong>不能同时拥有同一个对象</strong>，即：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;int&gt; ap1(p);</span><br><span class="line">auto_ptr&lt;int&gt; ap2(p);   &#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure></li>
<li>一个auto_ptr 被拷贝或赋值后，会失去堆原对象的所有权。此情况出现在auto_ptr作为函数值传递时。</li>
</ul>
<p><strong>2. shared_ptr</strong></p>
<ul>
<li>可以有多个shared_ptr指向同一个对象。</li>
<li>使用<strong>引用计数</strong>，记录多少个shared_ptr指向同一对象。一旦引用计数变为0，<strong>这个对象就自动删除</strong>，对非环形数据结构中防止资源泄露很有帮助。</li>
</ul>
<h2 id="1-unordered-map-常见操作"><a href="#1-unordered-map-常见操作" class="headerlink" title="1 unordered_map 常见操作"></a>1 unordered_map 常见操作</h2><h3 id="查找key是否存在"><a href="#查找key是否存在" class="headerlink" title="查找key是否存在"></a>查找key是否存在</h3><p>方法1:  若存在  mp.find(x)!=mp.end()<br>方法2:  若存在  mp.count(x)!=0</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法1：unordered_map&lt;key,T&gt;::iterator it;</span><br><span class="line">    (*it).first;   &#x2F;&#x2F;the key value</span><br><span class="line">    (*it).second   &#x2F;&#x2F;the mapped value</span><br><span class="line">    for(unordered_map&lt;key,T&gt;::iterator iter&#x3D;mp.begin();iter!&#x3D;mp.end();iter++)</span><br><span class="line">          cout&lt;&lt;&quot;key value is&quot;&lt;&lt;iter-&gt;first&lt;&lt;&quot; the mapped value is &quot;&lt;&lt; iter-&gt;second;</span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">    for(auto&amp; v : mp)</span><br><span class="line">        print v.first and v.second</span><br></pre></td></tr></table></figure>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>mp.insert(Map::value_type(1,”Raoul”));</p>
<hr>
<h2 id="2-vector"><a href="#2-vector" class="headerlink" title="2 vector"></a>2 vector</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p>vector<int> nums(n, 1)  //一维数组，长度为n，数组每行值为1</p>
<h5 id="二维数组初始化："><a href="#二维数组初始化：" class="headerlink" title="二维数组初始化："></a>二维数组初始化：</h5><p><code>vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(m, false));</code> //n行，m列</p>
<p><a href="https://www.jianshu.com/p/9a6aefcdf720" target="_blank" rel="noopener">动态创建二维数组</a>：</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector &lt;int&gt; &gt; ivec;</span><br><span class="line">ivec.resize(m);  </span><br><span class="line">for(int i&#x3D;0;i&lt;m;i++) ivec[i].resize(n);</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector &lt;int&gt; &gt; ivec;</span><br><span class="line">ivec.resize(m,vector&lt;int&gt;(n));</span><br></pre></td></tr></table></figure>
<h3 id="2-size"><a href="#2-size" class="headerlink" title="2.size()"></a>2.size()</h3><p>返回的是size_t类型，64位系统中为<code>long long unsigned int</code>，占8个字节。  </p>
<p>且vector的数组下标也是使用<code>size_t</code>类型.</p>
<p>【为什么使用size_t类型表示】：<br>在C++中为了提高代码的可移植性。</p>
<h3 id="3-返回数组最大值元素"><a href="#3-返回数组最大值元素" class="headerlink" title="3.返回数组最大值元素"></a>3.返回数组最大值元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return *max_element(maxF.begin(), maxF.end())</span><br></pre></td></tr></table></figure>
<h3 id="4-求交集"><a href="#4-求交集" class="headerlink" title="4.求交集"></a>4.求交集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_intersection(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), back_inserter(result));</span><br></pre></td></tr></table></figure>

<h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5.遍历"></a>5.遍历</h3><ul>
<li>迭代器遍历：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nums;</span><br><span class="line">for(vector&lt;int&gt; :: iterator iter &#x3D; nums.begin(); iter !&#x3D; nums.end(); ++iter)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>反向迭代器遍历：<br>反向迭代器reverse_iterator：从最后一个元素到第一个元素遍历容器。++iter 即为向前遍历。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; nums;</span><br><span class="line">for(vector&lt;int&gt;::reverse_iterator riter &#x3D; nums.rbegin(); riter !&#x3D; nums.rend(); ++riter)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h2 id="3-string"><a href="#3-string" class="headerlink" title="3 string"></a>3 string</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>键盘输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str(k, &#39;0&#39;) &#x2F;&#x2F;k个字符&#39;0&#39;</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char cha &#x3D; &#39;a&#39;;</span><br><span class="line">str +&#x3D; cha;</span><br></pre></td></tr></table></figure>

<h3 id="截取一段字符串"><a href="#截取一段字符串" class="headerlink" title="截取一段字符串"></a>截取一段字符串</h3><p>在C++ string类中，提供了两个成员函数可以用来实现字符串分割，一个是find函数，另一个是substr函数，下面看一下这两个函数的声明。</p>
<p>【find函数】:<br>原型： size_t find (const string&amp; str, size_t pos = 0) const;  </p>
<p>功能：查找子字符串第一次出现的位置。<br>参数说明：str为子字符串，pos为初始查找位置。<br>返回值：找到的话返回第一次出现的位置，否则返回<code>string::npos</code>。  </p>
<p>【substr函数】:<br>原型： string substr (size_t pos = 0, size_t len = npos) const;<br><code>string temp = strs.substr(pos, 2);</code><br>功能：在原字符串中截取子字符串。<br>参数说明：<strong>pos为起始位置</strong>，<strong>len为要截取子字符串的长度</strong>。<br>返回值：子字符串。  </p>
<h3 id="判断字符是否为十进制数字字符"><a href="#判断字符是否为十进制数字字符" class="headerlink" title="判断字符是否为十进制数字字符"></a>判断字符是否为十进制数字字符</h3><p>使用<code>isdigit(str)</code></p>
<h3 id="将数字字符化为int数字"><a href="#将数字字符化为int数字" class="headerlink" title="将数字字符化为int数字"></a>将数字字符化为int数字</h3><ul>
<li><p>使用<code>int x = str[i] -&#39;0&#39;</code></p>
</li>
<li><p><strong>string型数字字符串</strong>： <code>188</code>转化为int数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; 0;</span><br><span class="line">for(char c: str)&#123;</span><br><span class="line">    num &#x3D; num * 10 + (c - &#39;0&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; stoi(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>int转字符串：(k必须为个位数)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k &#x3D; 8;</span><br><span class="line">string str &#x3D; k + &#39;0&#39;;</span><br></pre></td></tr></table></figure>
<p>或者使用C++11的<code>to_string()</code>，此法较快</p>
<h3 id="获取输入的一整行string，-要空格"><a href="#获取输入的一整行string，-要空格" class="headerlink" title="获取输入的一整行string，(要空格)"></a>获取输入的一整行string，(要空格)</h3><ul>
<li>用<code>getline(cin, str)</code></li>
<li>用<code>cin &gt;&gt; str;</code> 不能获取输入字符串的<strong>空格</strong></li>
</ul>
<h3 id="sprintf-转换成十六进制"><a href="#sprintf-转换成十六进制" class="headerlink" title="sprintf()转换成十六进制"></a>sprintf()转换成十六进制</h3><h4 id="x转换成十六进制"><a href="#x转换成十六进制" class="headerlink" title="%x转换成十六进制"></a>%x转换成十六进制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[20];</span><br><span class="line">int n &#x3D; 10;</span><br><span class="line">sprintf(str,&quot;%x&quot;, n);</span><br></pre></td></tr></table></figure>
<p>结果是：str = “a”；十六进制中10对应a</p>
<h4 id="比较两字符串是否相等"><a href="#比较两字符串是否相等" class="headerlink" title="比较两字符串是否相等"></a>比较两字符串是否相等</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str1;</span><br><span class="line">string str2;</span><br><span class="line">str1.compare(str2) &#x3D;&#x3D; 0;则str1、str2相等</span><br><span class="line">str1.compare(0, str1.size(), str2) &#x3D;&#x3D; 0; 效果一样，判断str1 0 到 0+str1.size() 是否与str</span><br><span class="line">2相同。</span><br></pre></td></tr></table></figure>
<h4 id="字母大小写转换"><a href="#字母大小写转换" class="headerlink" title="字母大小写转换"></a>字母大小写转换</h4><p><code>char a = &#39;A&#39; ^ 32</code>;</p>
<h2 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h2><p><code>tuple</code>即元组，可以理解为<code>pair</code>的扩展，可以用来将不同类型的元素存放在一起，常用于函数的多返回值</p>
<h3 id="1-定义与初始化"><a href="#1-定义与初始化" class="headerlink" title="1.定义与初始化"></a>1.定义与初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;int,double,string&gt; tu &#x3D; &#123;1, 2.0, &quot;3&quot;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-访问"><a href="#2-访问" class="headerlink" title="2.访问"></a>2.访问</h3><p>可以使用<code>get&lt;常量表达式&gt;(tuple_name)</code>来访问或修改<code>tuple</code>的元素（返回引用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;int,double,string&gt; tu &#x3D; &#123;1, 2.0, &quot;3&quot;&#125;;</span><br><span class="line">get&lt;0&gt;(tu) &#x3D; 4;</span><br><span class="line">cout &lt;&lt; get&lt;1&gt;(tu) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>会输出2，因为<code>&lt;&gt;</code>中的数表示tuple的第几个元素。</p>
<h3 id="3-tie批量赋值"><a href="#3-tie批量赋值" class="headerlink" title="3.tie批量赋值"></a>3.<code>tie</code>批量赋值</h3><p>1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int f1,f2,f3;</span><br><span class="line">tie(f1,f2,f3) &#x3D; make_tuple(1, 2, 3);</span><br></pre></td></tr></table></figure>

<p>结果f1 = 1, f2 = 2, f3 = 3。</p>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;int,double,string&gt; tu &#x3D; &#123;1, 2.0, &quot;3&quot;&#125;;</span><br><span class="line">int i; double d; string s;</span><br><span class="line">tie(i, d, s) &#x3D; t3;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>会输出1 2 3</p>
<hr>
<h1 id="C-语法基础"><a href="#C-语法基础" class="headerlink" title="C++语法基础"></a>C++语法基础</h1><h3 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h3><p>预处理包括： </p>
<ul>
<li>宏定义、宏替换：宏替换的本质是–<strong>文本替换</strong>。编译时直接替换所指的文本。（不要当成函数）</li>
<li>文件包含</li>
<li>条件编译</li>
</ul>
<h3 id="全局变量、局部变量"><a href="#全局变量、局部变量" class="headerlink" title="全局变量、局部变量"></a>全局变量、局部变量</h3><ul>
<li>如果全局、局部变量同名，则<strong>局部变量会屏蔽全局变量。</strong></li>
<li><strong>不同文件中引用</strong>一个已经定义过的全局变量：用引用头文件、extern关键字。</li>
<li>同一文件中，如果全局变量被局部变量屏蔽，但又要使用全局变量：用extern、用作用域”::”</li>
</ul>
<h3 id="static-作用"><a href="#static-作用" class="headerlink" title="static 作用"></a>static 作用</h3><ul>
<li>不考虑类：<ul>
<li>隐藏：加了static的变量，<strong>对其他文件隐藏</strong>（其他文件不可见）。</li>
<li>默认初始化为0。</li>
<li>保持局部变量内容的持久性：函数静态局部变量的<strong>生命周期是整个源程序</strong>。</li>
</ul>
</li>
<li>类中static的作用：<br>表示这个变量或函数，属于这个类但不属于此类中<strong>任何对象</strong>，被每个成员对象共享。<ul>
<li>静态变量：必须在类内声明，<strong>在类外定义</strong>。受public等关键词作用。</li>
<li>静态函数：不与任何对象关联，因此没有<code>this</code>指针。<br>  因此<strong>无法访问类对象的非静态成员</strong>。</li>
</ul>
</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>把对象转换成<strong>常量</strong>，不能被修改。</li>
<li>用const代替#define的值替换功能：</li>
<li><strong>与#defin的区别</strong>：<ul>
<li>const有数据类型，define没有</li>
<li><code>#define x 100</code> 值替换时，可能导致代码出现多份100的备份。</li>
<li>const可以执行<strong>常量折叠</strong>（将常量表达式计算出结果）。</li>
</ul>
</li>
<li><strong>const指针</strong>。若要使指针本身成为一个const指针，需要把const放在*的右边：<code>int * const p</code></li>
<li><strong>函数参数与返回值</strong>。<ul>
<li>修饰函数参数：则此参数在函数体内<strong>不能被修改</strong>。<br>特别是在<strong>传递地址</strong>时，<code>fun(const int *p)</code>可以接收<code>int *</code>和<code>const int *</code>类型的参数；不经const修饰的传参只能接收<code>int*</code>。</li>
</ul>
</li>
<li>在类中：<ul>
<li>const成员函数：<code>void fun() const</code>：为了使该函数<strong>可作用于const对象</strong></li>
<li>const成员<strong>变量</strong>：使此变量为常量，但必须在类的构造函数的<strong>初始化列表中初始化</strong>，</li>
</ul>
</li>
</ul>
<h3 id="内存管理和释放"><a href="#内存管理和释放" class="headerlink" title="内存管理和释放"></a>内存管理和释放</h3><ol>
<li>c语言内存操作函数<br>使用<code>malloc</code>、<code>free</code>来在自由存储区中分配空间。C++中则对应的是<code>new</code>、<code>delete</code>。</li>
<li>C++内存管理<ul>
<li>隐式初始化：使用默认构造函数初始化：<code>string *p = new string</code></li>
<li>显式初始化：<code>int *p = new int ()</code> p指向一个初始化为0的int值。<code>int</code></li>
<li>释放内存：<code>delete</code>释放<code>new</code>分配的<strong>单个对象</strong>。用<code>delete[]</code>释放<code>new[]</code>分配的<strong>一组对象</strong> ：如回收<code>char *p = new char[64]</code>。</li>
</ul>
</li>
</ol>
<p><strong>const 对象的动态分配和回收</strong>：</p>
<ol>
<li>C++允许动态创建const对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int *p &#x3D; new const int(1024); &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
这是显式初始化，对于提供了默认构造函数的也可以隐式初始化。<br>与其他常量一样，动态创建的const对象必须在创建时初始化，并且之后不能修改。</li>
<li>删除const对象<br><code>delete p</code>来如其他动态对象一样，使用删除指针来释放。 </li>
</ol>
<p><strong>malloc/free和new/delete的区别</strong>：</p>
<ol>
<li><p>执行过程：<br> <strong>new的执行过程：</strong><br> 1.调用operator new库函数，2.分配一个足够大的未类型化的内存，3.然后运行该类型的构造函数，4.最后返回新分配并构造的对象的指针。（自动计算需要分配的内存）</p>
<p> <strong>delete的执行过程：</strong>  </p>
<ol>
<li>对所指对象运行适当的析构函数，2.再调用operator delete库函数释放该对象所用内存。</li>
</ol>
</li>
<li><p>malloc 不会调用构造函数，free不会调用析构函数。</p>
</li>
<li><p>new自动分配空间。malloc 需要手工计算字节数，且不识别要申请的内存是什么类型，只关心字节数。</p>
</li>
<li><p>new 内置了sizeof、类型转换和类型安全检查功能。所以是<strong>类型安全</strong>的。malloc 不是。</p>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li><strong>参数传递</strong>：<ul>
<li>形参：<strong>出现在函数定义中</strong>，在函数内部可以使用，离开函数不能使用。<br>实参：出现在<strong>函数外</strong>，加入函数内部后，实参变量不能使用。</li>
<li><strong>传递方法</strong>：1.值传递。2.指针传递。3.引用传递<code>void func(int &amp; a)</code>。<br>  引用传递：将形参指定为引用类型，对引用形参的任何修改会直接<strong>影响实参本身</strong>。而另外两种传递，是将实参的值<strong>复制</strong>到形参。</li>
<li><strong>传递指针的引用</strong>：形参<code>int * &amp; p</code>，</li>
</ul>
</li>
<li><strong>内联函数</strong><br> 让函数成为内联函数是为了<strong>消除调用函数的开销</strong>。因为编译时，会将内敛函数的调用处，<strong>直接替换为函数体</strong>，类似宏替换。所以内联函数要求小于10行。</li>
</ol>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>指在同一作用域内，可以有一组<strong>函数名相同，但参数列表不同</strong>的函数，这组函数就是重载函数。</p>
<p>作用：减少了函数、函数名的数量，避免名字空间的污染。</p>
<p>要求同名函数的参数列表中<strong>函数个数不同，或类型不同</strong>。</p>
<h3 id="函数模板与泛型"><a href="#函数模板与泛型" class="headerlink" title="函数模板与泛型"></a>函数模板与泛型</h3><p>泛型编程：以独立于任何特定类型的方式编写代码。可以自定义程序实例所操作的类型。如标准库中容器、迭代器、算法就是泛型编程的例子。</p>
<p>因此可以在任何类型上使用泛型的类和函数。</p>
<p>模板是泛型编程的基础。</p>
<h4 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h4><p>定义：</p>
<p>以关键词template开始，后接模板形参表。如下，func函数声明了一个名为<code>T</code>的<strong>类型形参</strong>。T 表示哪个实际类型，<strong>由编译器根据所传递的函数参数而确定</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename T2&gt;   &#x2F;&#x2F;假设有多个</span><br><span class="line">void func(const T &amp;a, const T &amp;b)&#123;</span><br><span class="line">    f(a&gt;b ? a: b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h4><p>类型函数模板，也可以为类定义一个模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">class Queue&#123;</span><br><span class="line">public:</span><br><span class="line">  Queue();</span><br><span class="line">  void push(const T &amp;);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用类模板时，必须为类模板类型形参<strong>显式指定实参</strong>，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;int&gt; q;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol>
<li><code>*p++</code>和<code>(*p)++</code>等价吗？<br>不等价。因为单目运算符<code>*</code>的优先级比<code>++</code>高，故 <code>*p++</code>先完成取值操作，然后<strong>对地址</strong>执行<code>++</code>操作，而<code>(*p)++</code>是先取值，然后<strong>对值</strong>进行<code>++</code>.</li>
<li><strong><code>void*</code>指针</strong>：<br>一种特殊类型的指针，可以保存<strong>任何类型对象</strong>的地址。</li>
<li><strong>指向指针的指针</strong><br>用<code>**</code>表示指向指针的指针。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int val &#x3D; 1024;int *p &#x3D; &amp;val; int **pi &#x3D; &amp;p;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>有题如</strong>：32位系统，求下述代码输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    double * (*a) [3][6];</span><br><span class="line">    cout &lt;&lt; sizeof(a) &lt;&lt;endl;   &#x2F;&#x2F;4</span><br><span class="line">    cout &lt;&lt; sizeof(*a) &lt;&lt; endl; &#x2F;&#x2F;4*18&#x3D;72</span><br><span class="line">    cout &lt;&lt; sizeof(**a) &lt;&lt; endl;    &#x2F;&#x2F;4*6&#x3D;24</span><br><span class="line">    cout &lt;&lt; sizeof(***a) &lt;&lt; endl;   &#x2F;&#x2F;4</span><br><span class="line">    cout &lt;&lt; sizeof(****a) &lt;&lt; endl;  &#x2F;&#x2F;8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答： a是一个类型为<code>double* (*)[3][6]</code>的指针，指向一个元素为<code>double*</code>类型的数组。<strong><code>*a</code>就是一个数组</strong>。<code>**a</code>为此数组首元素：一维数组<code>*a[0]</code>。<code>***a</code>是一维数组的一个元素，类型为double<em>。`***</em>a`的类型是double，大小为8个字节</p>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ol>
<li><p>即指向函数的指针。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool (*bf) (const string &amp;a1, const string &amp;a2);</span><br></pre></td></tr></table></figure>
<p>bf为指向函数的指针，这个函数有const string&amp;的形参和bool类型的返回值，<strong>且<code>*bf</code>要加括号</strong>。</p>
</li>
<li><p>用typedef简化函数指针的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef bool (*cmpFcn) (const string &amp;, const string &amp;);</span><br></pre></td></tr></table></figure>
<p>要使用上述函数指针类型时，直接使用<code>cmpFcn</code>即可，<strong>不必每次把整个类型声明全部写出来</strong>。</p>
</li>
<li><p>函数指针的形参可以是指向函数的指针。</p>
</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>从本质上说，引用还是指针，只不过这个指针<strong>不能修改</strong>，任何对它的操作都会发生在这个指针<strong>所指向的地方</strong>。</p>
<p>可以将引用理解为另一个对象的<strong>别名</strong>。</p>
<ol>
<li>不能定义引用的引用。</li>
<li>引用和指针的区别：<ul>
<li>引用不能为空，在创建时初始化。</li>
<li>引用的对象不能变更。</li>
<li>不可能有NULL引用。</li>
<li>sizeof(引用)得到指向的对象的大小，sizeof(指针)得到指针本身的大小。</li>
<li>对引用的操作是操作引用的对象，</li>
<li>使用&amp;取一个引用的地址时，其值为所引用变量的地址</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i&#x3D;3, j &#x3D;1;</span><br><span class="line">int &amp;ref &#x3D; i;   &#x2F;&#x2F;创建引用</span><br><span class="line">ref &#x3D; j;</span><br><span class="line">cout &lt;&lt; i;&#x2F;&#x2F;输出1</span><br></pre></td></tr></table></figure>

<h4 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h4><p>即指向const对象的引用。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int v &#x3D; 1000;</span><br><span class="line">const int &amp;ref &#x3D; v;</span><br><span class="line">int &amp;ref &#x3D; v;&#x2F;&#x2F;错误的，只能赋常量给常量引用。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>类中是const常量引用传递</strong>：<br>如<code>void func(const int &amp;a, const int &amp;b){...}</code>，就是在满足引用传递优点下（），还能做到不修改对象a、b。<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3></li>
</ul>
<h4 id="访问标号"><a href="#访问标号" class="headerlink" title="访问标号"></a>访问标号</h4><p>public、protected和private分别代表：公有、保护和私有。保护与私有类似，但保护成员在<strong>子类</strong>中可以访问。</p>
<p>类的成员函数、友元函数可以访问类中所有成员；但类外通过类的对象，就只能访问该类的公有成员。</p>
<h4 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h4><ol>
<li>成员函数：<strong>隐含的形参<code>this</code></strong>：每个成员函数都有。</li>
<li>构造函数：<ul>
<li>构造函数可以是内联的（当把构造函数的函数体写在类的定义体内），可以重载。<strong>但不能是虚函数</strong>。</li>
<li><strong>成员初始化列表</strong>（冒号和花括号之间）：如：<code>A() : j(0),i(2){}</code>，就是初始化<code>j、i</code>为<code>0、2</code>。<br>但如下代码有错：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A()&#123;</span><br><span class="line">    A(): j(0), i(j + 2) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  i 会是内存中的垃圾数字，j 会是 0。因为C++中，成员变量的初始化顺序与它们在<strong>初始化列表中的顺序无关</strong>。</li>
<li><strong>复制构造函数</strong>。<br>只有单个对本类类型的引用（用const修饰）的形参的构造函数，就是复制构造函数。  </li>
</ul>
</li>
<li>析构函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;* data *&#x2F;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;~A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line">public:</span><br><span class="line">    B(A &amp;a) : _a(a) &#123;   &#x2F;&#x2F;_a(a)调用了拷贝构造函数</span><br><span class="line">        cout &lt;&lt; &quot;B&quot;;</span><br><span class="line">    &#125; </span><br><span class="line">    ~B()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;~B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述代码会输出：<code>AB~B~A~A</code>。其中<strong>_a(a)调用了拷贝构造函数</strong>对B类对象中的A初始化，但拷贝构造函数调用的是系统的版本，没有输出。</li>
<li>构造函数与析构函数的调用顺序<ul>
<li>单继承时：派生时，<strong>构造函数和析构函数是不能继承的</strong>。因此需要在子类<strong>重新定义</strong>构造函数和析构函数：<strong>必须将基类构造函数放在子类的初始化列表中</strong>。<strong>创建时调用顺序</strong>：实例化子类对象时，先通过子类的构造函数调用父类的构造函数，再执行子类的构造函数。<strong>对象删除时调用顺序</strong>：先执行子类析构函数，再执行父类析构函数。</li>
<li>多继承：从最父类开始往下调用构造函数。</li>
<li>虚继承：先调用虚基类的构造函数，（如果虚基类有多个：则按照当前类派生表出现顺序进行调用），所有虚基类的构造函数调用完，然后按照多继承的规则调用其他构造函数。</li>
</ul>
</li>
<li>操作符重载：</li>
</ol>
<h4 id="成员函数的重载、覆盖和隐藏"><a href="#成员函数的重载、覆盖和隐藏" class="headerlink" title="成员函数的重载、覆盖和隐藏"></a>成员函数的重载、覆盖和隐藏</h4><ol>
<li>成员函数的<strong>重载</strong>（同一类中）：</li>
</ol>
<p><strong>同一类中同名函数</strong>存在的重载关系，但有不同的参数列表。且是否虚函数都可以重载。<br>2. <strong>覆盖</strong>（继承中）：指在子类中覆盖父类中的<strong>同名函数</strong>，要求基类函数必须是<strong>虚函数</strong>。且有<strong>相同参数个数、类型和返回类型</strong>。<br>3. <strong>隐藏</strong>：以下情况中，子类的函数屏蔽了父类的<strong>同名函数</strong>：<br>    - 参数相同，但父类函数<strong>不是虚函数</strong>。<br>    - 参数不同，无论父类是否虚函数，基类函数都会被隐藏。和重载的区别是，两个不同的类中。</p>
<hr>
<h2 id="输入cin："><a href="#输入cin：" class="headerlink" title="输入cin："></a>输入cin：</h2><ul>
<li><code>while( cin &gt;&gt; n)</code>输入没有结束，cin就会返回<code>true</code>.</li>
</ul>
<h2 id="输出cout"><a href="#输出cout" class="headerlink" title="输出cout"></a>输出cout</h2><ul>
<li>cin.tie与sync_with_stdio加速输入输出</li>
</ul>
<h2 id="“-gt-gt-”应用于求中值"><a href="#“-gt-gt-”应用于求中值" class="headerlink" title="“&gt;&gt;”应用于求中值"></a>“&gt;&gt;”应用于求中值</h2><p>“&gt;&gt;”为二进制的右移运算，可以代替数学中的除2运算，且更快。如：</p>
<p><code>int mid = left + ((right + left) &gt;&gt; 1)</code>等同于<br><code>int mid = (left + right) / 2</code></p>
<ul>
<li>另 <code>&lt;&lt;= 1</code>是二进制的数左移一位，理解为乘2.</li>
</ul>
<h2 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a><code>i++</code>和<code>++i</code>的区别</h2><p>1、首先，单独拿出来说++i和i++，意思都是一样的，就是i=i+1。<br>2、如果当做运算符来说，就是a=i++或者a=++i这样的形式。情况就不一样了。<br>先说<code>a=i++</code>，这个运算的意思是先把i的值赋予a，然后在执行i=i+1；  而a=++i，这个的意思是先执行i=i+1，然后在把i的值赋予a；</p>
<h3 id="cout设置输出数据不显示科学计数法"><a href="#cout设置输出数据不显示科学计数法" class="headerlink" title="cout设置输出数据不显示科学计数法"></a>cout设置输出数据不显示科学计数法</h3><p>【解决方案】</p>
<p>1、在头文件包含—<code>#include&lt;iomanip&gt;</code>——定义IO流输出输入格式控制相关函数。</p>
<p>2、利用cout输出格式为—<code>cout &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; temp &lt;&lt; endl;</code>—temp为输出数据。</p>
<p>【分析】——主要涉及到cout的格式化输出方面的知识</p>
<p>1、<code>cout &lt;&lt; fixed</code>——指一般方式（浮点）输出，不采用科学计数法输出<br>2、<code>setprecision(n)</code>——设置输出浮点数的精度，配合fixed设定，指的是小数位数，设置<code>setprecision(0)</code>即指输出不带小数位的int值。</p>
<hr>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是计算机已运行程序的实体。同<strong>一个程序可以有多个进程</strong>，以允许同时有多个用户运行同一程序。</p>
<ul>
<li><strong>进程有5种状态</strong>：前3个是基本状态<ul>
<li>运行、正在CPU上执行。</li>
<li>就绪、进程获得了除CPU外一切所需资源，就等CPU</li>
<li>阻塞、 等待某一事件而暂停</li>
<li>创建、正在被创建，尚未转到就绪</li>
<li>结束。正在从系统中消失。</li>
</ul>
</li>
<li>状态间的<strong>切换</strong>  </li>
</ul>
<p>三种基本状态（运行、就绪、阻塞）之间的切换，其中<strong>时间片到</strong>，就从运行态切换到就绪态。</p>
<ul>
<li><strong>创建新进程</strong>：子进程是父进程的复制品，在<strong>fork()</strong>后<strong>子进程获得父进程的数据空间、堆和栈的复制品</strong>，而线程使用当前的地址空间。  </li>
</ul>
<p><strong>如下程序：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 2; i++)&#123;</span><br><span class="line">        fork();</span><br><span class="line">        printf(&quot;-&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：8个“-”。为什么？</p>
<p>进程P1 fork()产生子进程P2，然后P1输出”-“;<br>进程P2 继承了i = 0，p2输出“-”后P2的i++，</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol>
<li>每个线程<strong>独占</strong>的资源–不能共享：<ul>
<li>线程ID</li>
<li>寄存器组的值</li>
<li>栈。（同一个进程的线程共享堆区）</li>
<li>错误返回吗</li>
<li>线程的信号屏蔽码</li>
<li>线程的优先级</li>
</ul>
</li>
<li>引入线程后，<strong>进程的内涵</strong>发送改变：进程作为<strong>除CPU以外的系统资源</strong>的分配单元（资源的基本单元）；线程作为<strong>CPU资源</strong>的分配单元（独立调度的基本单元）。<h4 id="3-进程与线程的区别："><a href="#3-进程与线程的区别：" class="headerlink" title="3. 进程与线程的区别："></a>3. 进程与线程的区别：</h4></li>
</ol>
<ul>
<li>调度</li>
<li>拥有资源</li>
<li>并发性</li>
<li>系统开销</li>
<li>地址空间和其他资源</li>
<li>通信方面</li>
</ul>
<h3 id="进程通信与进程同步"><a href="#进程通信与进程同步" class="headerlink" title="进程通信与进程同步"></a>进程通信与进程同步</h3><ol>
<li>Linux进程间通信手段<ul>
<li>管道、信号、消息队列、共享内存、信号量、套接字</li>
</ul>
</li>
<li>Linux线程间通信<ul>
<li>互斥量、信号量、条件变量</li>
</ul>
</li>
</ol>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ol>
<li>典型调度算法包括：先来先服务算法(FCFS)、 短作业优先算法(SJF)、 优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。<strong>其中SJF的平均等待时间、平均周转时间最少</strong>。</li>
<li>算法详解<ul>
<li>1.先来先服务算法：<strong>每次从就绪队列选择队首进程</strong>，进行运行，直到进程退出或阻塞，才从队列弹出下一个队首。（不利于短作业，因为长作业先运行了，短作业就会等待很长时间。）</li>
<li>短作业优先算法：<strong>优先选择运行时间最短的进程</strong>来运行。（对长作业不利，因为可能有非常多的短作业，致使长作业一直往后推。）</li>
<li>2.高响应比优先调度：<strong>优先运行响应比优先级高的</strong>。响应比优先级=（等待时间+要求服务时间）/ 要求服务时间。</li>
<li>3.时间片轮转调度：每个进程运行的时间片一样，<strong>一个时间片内没运行完的进程回到队尾</strong>。通常时间片为：<code>20ms ~ 50ms</code></li>
<li>4.最高优先级调度算法：从就绪队列<strong>选择最高优先级</strong>的进程运行。（可能会导致低优先级的进程永远不会运行）</li>
<li>5.多级反馈队列调度算法：综合了3和4.<br>有多个队列，队列优先级越高时间片越短；如果有<strong>新的进程加入优先级高的队列，立即停止当前进程</strong>，转而运行高优先级队列。</li>
</ul>
</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁指多个进程竞争资源而造成的僵局，如：进程P1有A资源，等待B资源；进程P2有B资源，等待A资源。</p>
<ol>
<li>死锁产生的条件（四个）<ul>
<li>互斥：在一段时间内某资源仅为一个进程所占有。</li>
<li>不可剥夺：进程已有资源，在未使用完之前，不能被强行夺走。</li>
<li>请求和保持：进程在请求另一个资源时，继续占有已有资源。</li>
<li>循环等待：存在一种进程资源的循环等待链，链中每个进程己获得的资源同时被链中下一个进程所请求。</li>
</ul>
</li>
<li>死锁处理策略<ul>
<li>预防死锁：设置限制条件，破坏死锁产生的四个条件。</li>
<li>避免死锁：如银行家算法。在资源的分配时，防止加入死锁。</li>
</ul>
</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h1 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h1><h2 id="1-数组指针、指针数组、数组名的指针操作"><a href="#1-数组指针、指针数组、数组名的指针操作" class="headerlink" title="1.数组指针、指针数组、数组名的指针操作"></a>1.数组指针、指针数组、数组名的指针操作</h2><h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><ul>
<li>算术运算：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 11;</span><br><span class="line">int const *p &#x3D; &amp;i;&#x2F;&#x2F;表示p指向i，且不能通过p修改i的值，但p本身不是const类型，可以修改。</span><br><span class="line">p++;</span><br><span class="line">printf(&quot;%d&quot;, *p);</span><br></pre></td></tr></table></figure>
这段代码的结果应该是输出<code>Garbage value</code>。因为<code>p++</code>后，指针p跳过i，指向下一个内存单元，但未定义，为一个垃圾值。</li>
<li>对于数组指针<ul>
<li>若指针指向数组的某个元素，则<code>p++</code>就指向下一个元素。</li>
<li>若<code>*p1 = a[1],*p2 = a[3]</code>，则<code>p1-p2 = 2, p2-p1 = -2;</code>。但若两指针指向不同数组的元素，则两者相减结果是未定义。</li>
</ul>
</li>
</ul>
<h3 id="指针数组、数组指针"><a href="#指针数组、数组指针" class="headerlink" title="指针数组、数组指针"></a>指针数组、数组指针</h3><ul>
<li>指针数组是指一个数组里面<strong>装着指针</strong>。</li>
<li><strong>数组指针</strong>就是一个指向数组的指针。<br>如：<code>int (*p)[10]</code>为声明一个数组指针。<ul>
<li>因为<code>[]</code>的优先级高于<code>*</code> ，所以必须添加<code>(*p)</code>。</li>
</ul>
</li>
<li>二维数组：<code>int a[4][10]</code>的<strong>数组名</strong>是一个<strong>数组指针</strong>。<br>如<code>int a[4][10]</code>。a的类型是<code>int (*)[10]</code>，即a指向二维数组的<strong>第一行数组</strong>。</li>
<li>对一维数组： <code>a[10]</code>，a的类型是<code>int *</code>，&amp;a的类型是<code>int(*)[10]</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int (*p)[10] &#x3D; &amp;a; </span><br><span class="line">int *q &#x3D; a;</span><br></pre></td></tr></table></figure>
其中，p是指向10个元素的数组的指针，<em>p的大小是40字节，*</em>故p+1跳过40个字节**（理解成跳到二维数组的下一行）。</li>
</ul>
<p>q是指向整型的指针，*q为4个字节，故q+1跳过4个字节。</p>
<ul>
<li><code>char *p = &quot;Hello&quot;</code>.存放该字符串的首地址装入指针。p指向位于文字常量区的字符串。可以用<code>p[0]</code>访问相应元素，<strong>但不能修改</strong>。</li>
</ul>
<h4 id="对于高维数组"><a href="#对于高维数组" class="headerlink" title="对于高维数组"></a>对于高维数组</h4><p>C++没有提供高维数组类型。二维数组就是：每个元素都是数组的数组。</p>
<p>如二维数组<code>int a[4][10]</code>：</p>
<ul>
<li><code>&amp;a</code>表示数组<code>a</code>的首地址。</li>
<li><code>a</code>是指向<code>a[0]</code>的指针，类型是<code>int(*) [10]</code>（因为a[0]是个数组）。<code>a</code>是常量不可修改，即不能<code>a += 2</code>，但可以创建一个指针p：<code>int *p = a; p += 2</code>。</li>
<li><code>*a</code>是指向<code>a[0][0]</code>的指针。</li>
<li><code>*(a+1)</code>是指向<code>a[1]</code>的指针。</li>
<li><code>*(*(a+1)+2)</code>是指向<code>a[1][2]</code></li>
</ul>
<hr>
<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h2><p>C++中通过<code>char * / const char *</code>类型的指针来操纵C语言风格的字符串。</p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul>
<li>strlen(const char <em>a)：计算字符数组的 *</em>字符数**，以 ‘\0’结束。</li>
<li>strcmp(char <em>a, char *b)：比较两个字符串 *</em>是否相等**。自左向右逐个字符相比，直到出现不同的字符。</li>
<li>strcat(char <em>a1, char *b2)：将b2所指的字符串 *</em>添加**到a1结尾处（覆盖a1结尾处的’\0’）并添加’\0’。</li>
<li>strcpy(a1, b2)：b2所指的字符串复制到a1开始的地址空间。</li>
</ul>
<h2 id="3-结构体struct"><a href="#3-结构体struct" class="headerlink" title="3.结构体struct"></a>3.结构体struct</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>C++的struct有很多class的功能。</p>
<ul>
<li>相同点：继承、构造函数、等特性相同  </li>
<li>不同点：class的成员<strong>访问权限默认是private</strong>，而struct成员的访问权限默认是<strong>public</strong>。</li>
</ul>
<p>struct的特性：</p>
<ul>
<li>不允许在结构体中对<strong>自身</strong>递归定义，但可以使用指针指向本类型。</li>
<li>中，可以<strong>包含其他结构体</strong>。</li>
<li>可以在定义时初始化<code>struct person {char name[10]; char sex;}boy1 = &quot;yang&quot;,&#39;M&#39;;</code></li>
</ul>
<h3 id="union-共用体"><a href="#union-共用体" class="headerlink" title="union 共用体"></a>union 共用体</h3><p>共用体中，同一时刻，共用体中<strong>只存放了一个被选中的成员</strong>，而结构体<strong>所有</strong>成员都存在。</p>
<p>另外，共同体、结构体的数据存放顺序是：<strong>所有成员都从低地址开始存放</strong>。</p>
<h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><ul>
<li>小端字节序：低位数据放在低地址处。<strong>如十六进制数<code>0x1420</code></strong>：<code>20</code>在低位，则存放在低地址中。</li>
<li>大端字节序：低位数据存放在高地址处。</li>
</ul>
<h3 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h3><p>创建符号常量的另一种方式，可以替代const。<br>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum spectrum &#123;</span><br><span class="line">    a,b,c,d &#x3D; 7,e,f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果a=0，b=1，c=2，d=7，e=8，f=9；</p>
<p>如果不给枚举赋初值，会默认给每个常量赋初值，第一个为0，<strong>其后成员按依次加1的规则</strong>。</p>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><ul>
<li>sizeof是单目运算符，不是函数，<strong>返回了字节大小</strong>（size_t，为<strong>unsigned int 类型</strong>）。</li>
<li>会忽略括号内的各种运算，如<code>sizeof(a++)</code>的<code>++</code>不执行。</li>
<li>计算数组、的空间大小</li>
<li>struct的空间大小：<ul>
<li>整体空间是占用空间最大的成员所占字节数的整数倍。但在32位Linux中，整体空间是4的倍数即可。</li>
<li>数据对齐元组原则。</li>
</ul>
</li>
<li>union、枚举空间的计算。</li>
<li>sizeof的部分结果：（单位：字节）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sizeof(int): 4</span><br><span class="line">sizeof(short): 2</span><br><span class="line">sizeof(long): 4</span><br><span class="line">sizeof(float): 4</span><br><span class="line">sizeof(double): 8</span><br><span class="line">sizeof(char): 1</span><br><span class="line">sizeof(p): 4 (32位指针是4，64位指针是8)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p><img src="https://pic2.zhimg.com/80/v2-55f42c78e51c0de9d1b942278ee1cfc1_720w.jpg" alt="image"></p>
<p><strong>每到一个新节点，将这个节点看做一个整体</strong><br><strong>前、中、后是按父节点所处位置划分</strong>  </p>
<p>以这个树为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   8</span><br><span class="line"> &#x2F;   &#x2F; \</span><br><span class="line">11  13  4</span><br></pre></td></tr></table></figure>
<ul>
<li>前中后序遍历递归写法的区别在于：记录进数组的时间点不同。</li>
</ul>
<p><strong>1. 前序遍历</strong><br>父节点-&gt;左子节点-&gt;右子节点：<br>前序遍历输出：<code>[5,4,11,null,8,13,4]</code>  </p>
<ul>
<li>递归写法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dfs_pre(vector&lt;int&gt;&amp; curTree, TreeNode* cur)&#123;&#x2F;&#x2F;前序遍历</span><br><span class="line">    if(cur &#x3D;&#x3D; nullptr)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    curTree.push_back(cur-&gt;val);    &#x2F;&#x2F;记录进数组</span><br><span class="line">    dfs_pre(curTree, cur-&gt;left);</span><br><span class="line">    dfs_pre(curTree, cur-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迭代写法</li>
</ul>
<p>压栈的顺序与遍历顺序相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; res;  &#x2F;&#x2F;保存结果</span><br><span class="line">    stack&lt;TreeNode*&gt; call;  &#x2F;&#x2F;调用栈</span><br><span class="line">    if(root!&#x3D;nullptr) call.push(root);  &#x2F;&#x2F;首先介入root节点</span><br><span class="line">    while(!call.empty())&#123;</span><br><span class="line">        TreeNode *t &#x3D; call.top();</span><br><span class="line">        call.pop();  &#x2F;&#x2F;访问过的节点弹出</span><br><span class="line">        if(t!&#x3D;nullptr)&#123;</span><br><span class="line">            if(t-&gt;right) call.push(t-&gt;right);  &#x2F;&#x2F;右节点先压栈，最后处理</span><br><span class="line">            if(t-&gt;left) call.push(t-&gt;left);</span><br><span class="line">            call.push(t);  &#x2F;&#x2F;当前节点重新压栈（留着以后处理），因为先序遍历所以最后压栈</span><br><span class="line">            call.push(nullptr);  &#x2F;&#x2F;在当前节点之前加入一个空节点表示已经访问过了</span><br><span class="line">        &#125;else&#123;  &#x2F;&#x2F;空节点表示之前已经访问过了，现在需要处理除了递归之外的内容</span><br><span class="line">            res.push_back(call.top()-&gt;val);  &#x2F;&#x2F;call.top()是nullptr之前压栈的一个节点，也就是上面call.push(t)中的那个t</span><br><span class="line">            call.pop();  &#x2F;&#x2F;处理完了，第二次弹出节点（彻底从栈中移除）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 中序遍历</strong><br>左子-&gt;父节点-&gt;右子：</p>
<p>即，<strong>每到一个新节点，将这个节点看做一个整体</strong>，先输出他的左孩子-&gt;再输出自己-&gt;输出右孩子。<br>中序遍历输出：<code>[11,4,null,5,13,8,4]</code></p>
<ul>
<li>递归写法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void dfs_mid(vector&lt;int&gt;&amp; curTree, TreeNode* cur)&#123;</span><br><span class="line">    if(cur !&#x3D; nullptr)&#123;</span><br><span class="line">        dfs_mid(cur-&gt;left);</span><br><span class="line">        curTree.push_back(cur-&gt;val);    &#x2F;&#x2F;记录进数组</span><br><span class="line">        dfs_mid(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迭代写法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(t!&#x3D;nullptr)&#123;</span><br><span class="line">    if(t-&gt;right) call.push(t-&gt;right);</span><br><span class="line">    call.push(t);  &#x2F;&#x2F;在左节点之前重新插入该节点，以便在左节点之后处理（访问值）</span><br><span class="line">    call.push(nullptr); &#x2F;&#x2F;nullptr跟随t插入，标识已经访问过，还没有被处理</span><br><span class="line">    if(t-&gt;left) call.push(t-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. 后序遍历</strong><br>左子-&gt;右子-&gt;父节点： </p>
<p>如上述二叉树：的后序遍历为：<code>[11,null,4,null,13,4,8,5]</code><br>即先找到最深处的最左侧节点-&gt;右子，<strong>但到根节点’5’的左孩子后</strong>，下一个是右子树最深处的左子节点。 </p>
<ul>
<li><p>递归法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void dfs_back(vector&lt;int&gt;&amp; curTree, TreeNode* cur)&#123;</span><br><span class="line">    if(cur !&#x3D; nullptr)&#123;</span><br><span class="line">        dfs_back(cur-&gt;left);</span><br><span class="line">        dfs_back(cur-&gt;right);</span><br><span class="line">        curTree.push_back(cur-&gt;val);    &#x2F;&#x2F;记录进数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代法 （只写出了与前序、中序迭代法<strong>不同的地方</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(t!&#x3D;nullptr)&#123;</span><br><span class="line">    call.push(t);  &#x2F;&#x2F;在右节点之前重新插入该节点，以便在最后处理（访问值）</span><br><span class="line">    call.push(nullptr); &#x2F;&#x2F;nullptr跟随t插入，标识已经访问过，还没有被处理</span><br><span class="line">    if(t-&gt;right) call.push(t-&gt;right);</span><br><span class="line">    if(t-&gt;left) call.push(t-&gt;left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>4. 层次遍历</strong><br>严格按照自上而下、自左向右的顺序访问树的节点</p>
<p>用<strong>队列</strong>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Traverse_level(vector&lt;int&gt;&amp; curTree, TreeNode* cur) &#123;</span><br><span class="line">    if(!cur)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(cur);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        TreeNode* node &#x3D; q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        curTree.push_back(node-&gt;val);   &#x2F;&#x2F;记录进数组</span><br><span class="line">        if(node-&gt;left)&#123;</span><br><span class="line">            q.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node-&gt;right)&#123;</span><br><span class="line">            q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他方法记录"><a href="#其他方法记录" class="headerlink" title="其他方法记录"></a>其他方法记录</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int test&#x3D;64;</span><br><span class="line">cout&lt;&lt;&quot;DEC:&quot;&lt;&lt;test&lt;&lt;endl;   &#x2F;&#x2F;输出test的十进制</span><br><span class="line">cout&lt;&lt;&quot;OCT:&quot;&lt;&lt;oct&lt;&lt;test&lt;&lt;endl;&#x2F;&#x2F;八进制</span><br><span class="line">cout&lt;&lt;&quot;HEX:&quot;&lt;&lt;hex&lt;&lt;test&lt;&lt;endl;&#x2F;&#x2F;十六进制</span><br></pre></td></tr></table></figure>
<p>输出：<br>“DEC”:64<br>“OCT”:100<br>“HEX”:40  </p>
<hr>
<h2 id="two-pointers"><a href="#two-pointers" class="headerlink" title="two pointers"></a>two pointers</h2><h3 id="什么是two-pointers"><a href="#什么是two-pointers" class="headerlink" title="什么是two pointers"></a>什么是two pointers</h3><p>以一个<strong>例子</strong>引入:<br>给定一个递增的正整数序列和一个正整数M，求序列中的两个不同位置的数a和b,使得它们的和恰好为M,输出所有满足条件的方案。<br>例如给定序列{1,2,3,4,5,6}和正整数M=8，就存在2+6=8与3+5=8成立。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最复杂的方法：</span><br><span class="line">for(int i&#x3D; 0; i&lt; n; i++) &#123;</span><br><span class="line">    for(intj&#x3D;i+1;j&lt; n;j++) &#123;</span><br><span class="line">        if(a[i] + a[j] &#x3D;&#x3D; M) &#123;</span><br><span class="line">            printf(&quot;&amp;d 8d\n&quot;, a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度<code>$O(n^2)$</code><br><strong>思路</strong><br>充分利用序列递增性质，令下标<code>i</code>的初值为<code>0</code>，下标<code>j</code>的初值为<code>n-1</code>，接下来根据<code>a[i] +  a[j]</code>与<code>M</code>的大小来进行下面三种选择，使i不断向右移动、使<code>j</code>不断向左移动，直到<code>i≥j</code> 成立。<br>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(i &lt; j)&#123;</span><br><span class="line">    if(a[i] + a[j] &#x3D;&#x3D; M)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a[i] + a[j] &lt; M) i++;</span><br><span class="line">    else j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法复杂度为<code>$O(n)$</code></p>
<h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>C++ 语言支持【分别编译】（separatecompilation）<br>也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。 </p>
<p>【比如】，在文件 a.cpp 中定义了一个全局函数 “void a(){}”，而在文件 b.cpp 中需要调用这个函数。即使这样，文件 a.cpp 和文件 b.cpp 并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。</p>
<p>【这是怎么实现的呢？】<br>从写程序的角度来讲，很简单。在文件 b.cpp 中，在调用 “void a()” 函数之前，先声明一下这个函数 “voida();”，就可以了。这是因为编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 “void a()” 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。</p>
<p>【头文件】<br>所谓的头文件，其实它的内容跟 .cpp 文件中的内容是一样的，都是 C++ 的源代码。但头文件不用被编译。我们把所有的<strong>函数声明</strong>全部放进一个头文件中，当某一个 .cpp 源文件需要它们时，它们就可以通过一个宏命令 “#include” 包含进这个 .cpp 文件中，从而把它们的内容合并到 .cpp 文件中去。当 .cpp 文件被编译时，这些被包含进去的 .h 文件的作用便发挥了。</p>
<h4 id="【makefile】"><a href="#【makefile】" class="headerlink" title="【makefile】"></a>【makefile】</h4><p>由 目标target 、 依赖prerequisites 、 命令recipe 组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target ..: prerequisites ...</span><br><span class="line">    recipe </span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>如一个hello.cpp 的编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello: hello.cpp</span><br><span class="line">    gcc -o hello hello.cpp</span><br></pre></td></tr></table></figure>

<p>【赋值 ?=, +=, = 和 := 的差别】</p>
<ul>
<li>?= 如果没有被赋值过就赋予等号后面的值</li>
<li>+= 添加等号后面的值</li>
<li>= 最基本的赋值(最后才展开)<br>make会将整个makefile展开后，再决定变量的值。也就是说，变量的值展开是在最后, 使我们可以在最后才指定变量的值。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; XXX</span><br><span class="line">y &#x3D; $(x)</span><br><span class="line">x &#x3D; YYY</span><br></pre></td></tr></table></figure>
最后 x 的值是 YYY，而不是 XXX。</li>
<li>:= 是覆盖之前的值(类似C中的 = )<br>变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。<br>x := XXX</li>
</ul>
</div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/09/11/sort_sum/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">排序算法总结</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By feng</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>